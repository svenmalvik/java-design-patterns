
== Java Design Patterns

=== com.iluwatar.abstractfactory.App
++++
The Abstract Factory pattern provides a way to encapsulate a group of individual factories that have a common theme
 without specifying their concrete classes. In normal usage, the client software creates a concrete implementation of
 the abstract factory and then uses the generic interface of the factory to create the concrete objects that are part
 of the theme. The client does not know (or care) which concrete objects it gets from each of these internal
 factories, since it uses only the generic interfaces of their products. This pattern separates the details of
 implementation of a set of objects from their general usage and relies on object composition, as object creation is
 implemented in methods exposed in the factory interface.
 <p>
 The essence of the Abstract Factory pattern is a factory interface ({@link KingdomFactory}) and its implementations (
 {@link ElfKingdomFactory}, {@link OrcKingdomFactory}). The example uses both concrete implementations to create a
 king, a castle and an army.
++++


=== com.iluwatar.tls.App
++++
ThreadLocal pattern
 <p>
 This App shows how to create an isolated space per each thread. In this
 example the usage of SimpleDateFormat is made to be thread-safe. This is an
 example of the ThreadLocal pattern.
 <p>
 By applying the ThreadLocal pattern you can keep track of application
 instances or locale settings throughout the handling of a request. The
 ThreadLocal class works like a static variable, with the exception that it is
 only bound to the current thread! This allows us to use static variables in a
 thread-safe way.
 <p>
 In Java, thread-local variables are implemented by the ThreadLocal class
 object. ThreadLocal holds a variable of type T, which is accessible via get/set
 methods.
 <p>
 SimpleDateFormat is one of the basic Java classes and is not thread-safe. If
 you do not isolate the instance of SimpleDateFormat per each thread then
 problems arise. 
 <p>
 App converts the String date value 15/12/2015 to the Date format using the
 Java class SimpleDateFormat. It does this 20 times using 4 threads, each doing 
 it 5 times. With the usage of as ThreadLocal in DateFormatCallable everything 
 runs well. But if you comment out the ThreadLocal variant (marked with "//TLTL") 
 and comment in the non ThreadLocal variant (marked with "//NTLNTL") you can 
 see what will happen without the ThreadLocal. Most likely you will get incorrect 
 date values and / or exceptions.
 <p>
 This example clearly show what will happen when using non thread-safe classes
 in a thread. In real life this may happen one in of 1.000 or 10.000 conversions
 and those are really hard to find errors.
++++


=== com.iluwatar.builder.App
++++
The intention of the Builder pattern is to find a solution to the telescoping constructor
 anti-pattern. The telescoping constructor anti-pattern occurs when the increase of object
 constructor parameter combination leads to an exponential list of constructors. Instead of using
 numerous constructors, the builder pattern uses another object, a builder, that receives each
 initialization parameter step by step and then returns the resulting constructed object at once.
 <p>
 The Builder pattern has another benefit. It can be used for objects that contain flat data (html
 code, SQL query, X.509 certificate...), that is to say, data that can't be easily edited. This
 type of data cannot be edited step by step and must be edited at once. The best way to construct
 such an object is to use a builder class.
 <p>
 In this example we have the Builder pattern variation as described by Joshua Bloch in Effective
 Java 2nd Edition.
 <p>
 We want to build {@link Hero} objects, but its construction is complex because of the many
 parameters needed. To aid the user we introduce {@link Builder} class. {@link Hero.Builder}
 takes the minimum parameters to build {@link Hero} object in its constructor. After that
 additional configuration for the {@link Hero} object can be done using the fluent
 {@link Builder} interface. When configuration is ready the build method is called to receive
 the final {@link Hero} object.
++++


=== com.iluwatar.factory.method.App
++++
The Factory Method is a creational design pattern which uses factory methods to deal with the
 problem of creating objects without specifying the exact class of object that will be created.
 This is done by creating objects via calling a factory method either specified in an interface
 and implemented by child classes, or implemented in a base class and optionally overridden by
 derived classesâ€”rather than by calling a constructor.
 <p>
 In this Factory Method example we have an interface ({@link Blacksmith}) with a method for
 creating objects ({@link Blacksmith#manufactureWeapon}). The concrete subclasses (
 {@link OrcBlacksmith}, {@link ElfBlacksmith}) then override the method to produce objects of
 their liking.
++++


=== com.iluwatar.prototype.App
++++
The Prototype pattern is a creational design pattern in software development. It is used when the
 type of objects to create is determined by a prototypical instance, which is cloned to produce
 new objects. This pattern is used to: - avoid subclasses of an object creator in the client
 application, like the abstract factory pattern does. - avoid the inherent cost of creating a new
 object in the standard way (e.g., using the 'new' keyword)
 <p>
 In this example we have a factory class ({@link HeroFactoryImpl}) producing objects by cloning
 the existing ones. The factory's prototype objects are given as constructor parameters.
++++



